import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd

#convert a dataframe date column to a list of datetimes
#df is original dataframe, date is name of date column title
def to_datetime(df, date):
    y = [0]*len(df[date])
    i=0
    for x in df[date]:
        y[i] = x.to_pydatetime()
        i=i+1
    return(y)

#create a selective dataframe by specifying a parameter
#df is original dataframe, p is parameter selecting by, s is selected parameter value
def df_select(df, p, s):
    new_df = df[df[p] == s]
    return(new_df)

#create new data frame that only includes values > 0
# df is original dataframe, V is name of values column
def df_omit_zeros(df, v):
    df_new = df[df[v] > 0.0]
    return(df_new)
#choose floor value other than zero default
def df_floor(df, v, f):
    df_new = df[df[v] > f]
    return(df_new)

#The following functions will be specific to dataframes generated by DMS with date column labelled "Date"

#performs the previous three functions on a data frame and returns one list and two dataframes
def basic_df_ops(df, p, s):
    data_p = df_select(df, p, s)
    x_p = to_datetime(data_p, "Date")
    data_p_n0 = df_omit_zeros(data_p, "Value")
    x_p_n0 = to_datetime(data_p_n0, "Date")
    return([data_p, x_p, data_p_n0, x_p_n0])

#carry out basic_df_ops but with floor specified instead of set at zero
def df_ops_f(df, p, s, f):
    data_p = df_select(df, p, s)
    x_p = to_datetime(data_p, "Date")
    data_p_f = df_floor(data_p, "Value", f)
    x_p_f = to_datetime(data_p_f, "Date")
    return([data_p, x_p, data_p_f, x_p_f])

#sync the time stamps of df_2 with df_1
#returns an array of values of df_2 that are synced with the timestamps of df_1
#where df_1 has a value for a particular timepoint, but df_2 does not, returns a NA value for that index of the output array
#where df_2 has a value for a particular timepoint, but df_1 does not, that value and timepoint are omitted from output array
def time_sync(df_2, df_1):
    dates = df_1["Date"]
    y = [0]*len(dates)
    i = 0
    for x in dates:
        instantaneous_df_2 = df_2[df_2["Date"] == x]
        value_2 = instantaneous_df_2.iloc[0][3]
        y[i] = value_2
        i = i+1
    y = np.array(y)
    return(y)

def time_sync_2(df_1, df_2):
    df_1_new = df_1[df_1['Date'].isin(df_2['Date'])]
    df_2_new = df_2[df_2['Date'].isin(df_1['Date'])]
    x = to_datetime(df_1_new, "Date")
    return(df_1_new, df_2_new, x)

#unit conversion where p is parameter to be converted, and f is conversion factor
def conv_units(df, p, f):
    y = [0]*len(df[p])
    i = 0
    for x in df[p]:
        y[i] = x*f
        i = i+1
    y = np.array(y)
    return(y)

def conv_units_2(df, f, date_index, value_index, Value):
    x = [0]*len(df['Date'])
    y = [0]*len(df['Date'])
    for i in range(0, len(df['Date'])):
        x[i] = df.iloc[i][date_index]
        y[i] = df.iloc[i][value_index]*f
    new_df = pd.DataFrame( data = np.array(y).T, columns = [Value] )
    new_df.loc[:,"Date"] = pd.Series(x)
    return(new_df)


#plot a linear regression on a graph
#specify x, y, ax, mf, mpx, and mpy. mf is marker format, mpx is x text placement, mpy is y text placement.
def plt_lin_reg(x, y, ax, mf, mpx, mpy):
    m, b, r, p, se = stats.linregress(x, y)
    x_r = [min(x), max(x)]
    y_r = [m*min(x)+b, m*max(x)+b]
    rs = str(round(r**2, 2))
    m_ = str(round(m, 2))
    b_ = np.around(b).astype('str')
    ax.plot(x_r, y_r, mf)
    ax.text( min(x)+mpx*(max(x)-min(x)), (m*min(x)+b)+mpy*((m*max(x)+b)-(m*min(x)+b)), 'y = '+ m_ +'x + ' + b_ + '\n' + 'r' + r'$^2$' + ' = ' + rs, horizontalalignment = 'center' )

def plt_lin_reg_2(x, y, ax, mf, mpx, mpy):
    m, b, r, p, se = stats.linregress(x, y)
    x_r = [min(x), max(x)]
    y_r = [m*min(x)+b, m*max(x)+b]
    rs = str(round(r**2, 2))
    m_ = str(round(m, 2))
    b_ = np.around(b).astype('str')
    ax.plot(x_r, y_r, mf)
    ax.text( mpx, mpy, 'y = '+ m_ +'x + ' + b_ + '\n' + 'r' + r'$^2$' + ' = ' + rs, c = mf[1], horizontalalignment = 'center' )

#plot linear regression without text
def plt_line_reg(x, y, ax, mf):
    m, b, r, p, se = stats.linregress(x, y)
    x_r = [min(x), max(x)]
    y_r = [m*min(x)+b, m*max(x)+b]
    rs = np.around(r**2, 2).astype('str')
    m_ = np.around(m, 2).astype('str')
    b_ = np.around(b, 2).astype('str')
    ax.plot(x_r, y_r, mf)

def plt_lin_reg_y_int(x, y, ax, mf, mpx, mpy):
    m, b, r, p, se = stats.linregress(x, y)
    x_r = [0, max(x)]
    y_r = [m*0+b, m*max(x)+b]
    rs = str(round(r**2, 2))
    m_ = str(round(m, 2))
    b_ = np.around(b).astype('str')
    ax.plot(x_r, y_r, mf)
    ax.text( mpx, mpy, 'y = '+ m_ +'x + ' + b_ + '\n' + 'r' + r'$^2$' + ' = ' + rs, c = 'k', horizontalalignment = 'center' )


